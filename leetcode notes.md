# 一、个人习惯

1. 自定义的右指针right能包含就包含

2. 如果难理解的边界条件，尽量使用<= n - 1，而不是< n

3. 自定义的第k大，习惯于都以1开始

4. 若第k大以1开始，则
   $$
   \text{奇数length数组的中位数所在的k} = (length + 1)/2 \\
   \text{偶数length数组的中位数所在的k} = ((length / 2) + (length / 2) + 1) /2.0
   $$
   
5. 

5. 中文英文语义里的第几个默认从1开始

7. 谨记，题目所给的是没有哑结点的，所以要加个防止删除第一个节点（即头节点）无法回收空间

8. 若right不含本数，i<(right + left)/2即可遍历中值（不含）往左的所有数 

   mid在含和不含思考方式：取3和4，分别求证

9. 二分查找while(left <= right)

# 二、经验总结

#### 回溯法

- 对于**寻找所有可能解**的题，都可以尝试使用回溯法
- 回溯法搜索时使用的是dfs
- 可以尝试剪枝加快运行
- 如17题、39题



# 二、题目

#### 78. 子集

- (1) 回溯
- (2) **位运算**：每一个数字的选与不选，都相当于一个01序列。总共n个数字就相当于长度为n的01序列。**本题可以用来练习位运算！**

#### 76. 最小覆盖子串

- **滑动窗口**！
- 经典滑动窗口题。**有很多细节，可以锻炼滑动窗口的书写，是很好的一题！**

#### 75. 颜色分类

- 双指针：(1)可以都从左侧开始的p0，p1  (2)也可以一个从左侧即p0，一个从右侧即p2
- 下列说明的是（2）左右双指针的方法：
- 注意i只需要遍历到p2的位置
- 注意要先判断2再判断0，因为在p2时换过后的nums[i]可能是0，若对调顺序就错过了
- 本体最重要的是指针的移动：因为遍历是从左到右的，和p0交换后没关系后续随p0的移动此时的nums[i]还会被遍历到。但和p2交换时，被交换后的nums[i]（原本p2所指的未知的值）还有可能是2，因为p2是从右到左的，所以到下个循环我们讨论的是nums[i+1]而nums[i]不再被考虑，而这个2被错误的忽视了！
- 所以当我们找到 2 时，我们需要**不断**地将nums[i]（i不动）与新的nums[p2]（p2动）进行交换

#### 72. 编辑距离

- 经典动态规划
- 记得只用两个数组来优化，而不是使用占用空间很大的dp二维矩阵
- **有很多细节需要注意，很值得多做几次！**

#### 64. 最小路径和

- 是 第62题不同路径 的扩展，显然动态规划

#### 62. 不同路径

- 思路: 动态规划！

- (1) **动态规划**！`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`

- (2) 组合数学C_{m+n-2}^{m-1}：总共要走m-1+n-1步，在这m+n-2步里挑m-1步向下

  注意不能ans *= top / bottom; 而应该分开写成ans *= top; ans /= bottom;

#### 56. 合并区间

- 思路：根据每个数组的第一个元素对intervals进行排序
- 若ans为空，或当前interval左区间大于ans.back()的右区间，直接将当前interval插入ans
- 否则改变ans.back()的右区间为原先右区间与当前interval右区间的最大值

#### 55. 跳跃游戏

- 贪心算法。课上讲过

#### 53. 最大子序和

- 思路：动态规划

- dp[i]：以nums[i]结尾的的连续子数组的和

- 返回所有dp[i]里的最大值

#### 49. 字母异位分组

- 思路：哈希，键可以有两种：

- (1) 排序好了的string
- (2) 相同构成的string的字母出现次数是一样的，所以key是一个统计26个字母次数的array

#### 48. 旋转图像

- 要求原地翻转

- 数学题
- 顺时针旋转90° == 水平翻转+左上到右下的对称轴翻转 == 竖直翻转+右上到左下的对称轴翻转 
- 注意：水平翻转只遍历一半的数据，所以上述两式不能合并
- 注意: 水平翻转(i < n/2) 和 对角线翻转(j<i) 的遍历条件！！

#### 46. 全排列

- 典型**回溯法**
- **好方法：**需要记录哪些元素用过。为了节省空间，用swap(元素1，元素2)将用过的元素都放到前面。

#### 42. 接雨水

- 经典题！
- (1)动态编程O(N),O(N)：和暴力法差不多，只是用两个数组记录下左遍历和右遍历的最大值：对每个桩，查找往左侧望过去最高的桩，往右侧望过去最高的桩
- (2)**栈**O(N),O(N)：横向看来计算水量。当当前高度比栈顶小就入栈，若大就出栈，计算高度和距离
- (3)**双指针O(N),O(1)**：是动态编程的优化。发现某个桩能装水的量只由左边或右边最小的那个值界定，所以每次只移动较小的那个指针：若比记录的max大，则更新max，否则计算水量。总共遍历一次就行了，且只需要常数空间。

#### 39. 无重复数组里所有和为target的组合

- 回溯法

#### 34. 在排序数组中查找元素的第一个和最后一个位置

- 思路：二分查找

- leftIdx第一个大于等于target的下标

- rightIdx第一个大于target的下标-1

- 还要判断是否leftIdx和rightIdx所指的元素是否是target，否则返回[-1, -1]

#### 33. 搜索旋转排序数组

- **二分查找**
- 二分查找不需要递归！归并排序才需要递归！虽然二者都使用了left、mid、right。二分查找经常用在已经排好序的数组中
- 本题是很好的题！没用什么难的算法，但很考验编程能力和细节

#### 32. 最长有效括号

- 本题较难

- 有三种方法：动态规划、栈、正反逆向遍历
- 可以用动态规划做。后两种比较难想到

#### 31. 下一个排列

- 数学题

- （1）从右侧往左找到第一个山峰

  （2）从右往左找到山峰右侧中第一个比nums[i]小的数

  （3）交换，可以确保山峰右侧仍是递减的

  （4）把山峰右侧翻转成递增

#### 23. 合并K个升序链表

- **归并排序**：定义（1）merge两个ListNode的函数，即正常的链表操作 （2）对一堆ListNodes进行二分排序，参数是lists、left、right（含本数）、mid

#### 18. 删除链表的倒数第N个节点

- 要求一趟扫描，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。
- 谨记，题目所给的是没有哑结点的，所以要加个防止删除头节点时无法回收空间

#### 17. 电话号码的字母组合

- **回溯**

#### 15. 三数之和

- b变大后，c肯定变小

- **排序+双指针**
- 双指针：如果一个元素的递增，必将造成另一个元素的递减，就可以用双指针。这样的话时间复杂度将从O(N^2)讲到O(N)

#### 11. 盛最多水的容器

- 经典**双指针问题**
- 双指针问题：每次将一个指针往另一个指针的方向移动
- 每次只移动那个矮一点的指针，因为这个指针如果再作为边界容量肯定更小

#### 10. 正则表达式匹配

- **动态规划**
- 若是*，则有2种情况：（1）匹配0个前面的字符，将该组合扔掉（2）匹配至少一个字符，将s中该末尾字符扔掉，组合还可以继续匹配
- 注意match的书写，要判断p[j]=='.'的情况。而且若i==0，则输出false

#### 5. 最长回文子串

- 经典三种方法：**动态规划**、**中心扩散法**、**马拉车算法**

- 中心扩散法，遍历，对每个i调用`palindromeAroundCenter(s, i, i)`;和`palindromeAroundCenter(s, i, i + 1);`
- (string).substr(起始的i，不含本数的长度）

#### 4. 寻找两个正序数组的中位数

- **寻找两个数组的第k小元素的变种**
- **本题非常有助于思考第k大和+1 -1的边界条件**

#### 3. 无重复字符的最长字串

- **滑动窗口**：关键词：**最长连续**之类的词...（下一个left时，从left到right显然是符合题意的）
- `(unordered_set).insert(elem)`: 从set里增加一个元素
- `(unordered_set).erase(elem)`: 从set里删除一个元素
- `(unordered_set).count(elem)`: 从set里查找一个元素的数量

#### 2. 两数相加

- 题目参数的ListNode没有头节点
- 若不需要在开头插入节点，则可以不用头节点
- 使用两个指针：头指针head和尾指针tail，便于往后添加节点
- 可以直接改变输入的指针，即`l1 = l1 -> next`

#### 1. 两数之和

- 使用unordered_map加快搜索
- `(unordered_map).find(elem)` 从map里查找元素，返回的是一个iterator，使用(iterator)->first和(iterator)->second访问键和值。找不到的话返回(map).end(）
- `(unordered_map).count(elem)` 返回的直接就是数字，更直观
- 返回vector可以直接用return {elem1，elem2};

#### 239. 滑动窗口最大值

双端队列deque，有push_back和pop_back。单调队列的 push 方法依然在队尾添加元素，但是要把前面比新元素小的元素都删掉，在维护单调栈的时候用的是元素下标，而非元素实际的值，就是为了判断栈顶何时出栈（当窗口左端已经pass栈顶下标的时候）。单调栈的典型用途是用于找到数组中下一个比自身大的元素（the next greater element, NGE），可以在一次遍历就获得所有元素的NGE。907，739，503类似



# 三、C++常用方法

1. ```c++
   unordered_map<int,int> mp；//
   ```

2. ```c++
   sort(nums.begin(),nums.end());//进行排序
   ```

3. ```c++
   ListNode head, *tail = &head;//使用头节点
   return head.next;
   ```
4. ```c++
   (vector).emplace_back(数据); 不采用拷贝构造函数，直接插入，比push_back更快。适用于往二维数组里插入数组
   ```

5. ```c++
   array<int, 26>在初始化时必须指定大小，并且
   ```

6. 

# 四、Go常用方法

1. Go没有堆栈队列，需要自己用slice实现